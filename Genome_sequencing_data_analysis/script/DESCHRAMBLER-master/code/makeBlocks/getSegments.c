/* *************************************************************
 * This program reads raw.segs generated by readNets. It then
 * segments them into pieces that will be used in partionGenomes
 * procedure.
 * ************************************************************/

#include "util.h"
#include "species.h"

#define SUFFIX	"raw.segs"
#define SUFFIX2	"processed.segs"

struct my_seg_list {
	char fchr[50], schr[50];
	int fbeg, fend, sbeg, send;
	int cid;
	char orient;
	struct my_seg_list *next;
};

void free_my_seg_list(struct my_seg_list *sgl) {
	struct my_seg_list *p, *q;
	p = sgl;
	for (;;) {
		q = p->next;
		free(p);
		if (q == NULL)
			break;
		else
			p = q;
	}
}

int main(int argc, char* argv[]) {
	FILE *pf, *of;
	char buf[500], prev[50], fub[500], segfile[200], outfile[200];
	char gapchrom[50], fchrom[50], schrom[50];
	struct my_seg_list *slist, *plast, *p, *r, *q, *prp;
	int level, tobreak, fgapbeg, fgapend, sgapbeg, sgapend, b1, e1, b2, e2, rs, ss;
	char type, gaporient, ori;

	if (argc != 2)
		fatal("arg: configure-file");

	get_spename(argv[1]);
	rs = ref_spe_idx();
	
	for (ss = 1; ss < Spesz; ss++) {
		if (ss == rs)
			continue;
		slist = p = plast = r = prp = NULL;
		prev[0] = '\0';
		tobreak = 0;
		sprintf(segfile, "%s.%s", Spename[ss], SUFFIX);
		fprintf(stderr, "- processing %s\n", segfile);
		pf = ckopen(segfile, "r");
		sprintf(outfile, "%s.%s", Spename[ss], SUFFIX2);
		of = ckopen(outfile, "w");
	
		while (fgets(buf, 500, pf)) {
			sscanf(buf, "%d %c %*s", &level, &type);
			if (level == 0 && type == 's') {
				// no need to break and insert, just append to the list
				p = (struct my_seg_list *)ckalloc(sizeof(struct my_seg_list));
				p->next = NULL;
				if (sscanf(buf, "%*d %*c %*[^.].%[^:]:%d-%d %*[^.].%[^:]:%d-%d %c %d",
						   p->fchr, &(p->fbeg), &(p->fend),
						   p->schr, &(p->sbeg), &(p->send), 
						   &(p->orient), &(p->cid))  != 8)
					fatalf("cannot parse: %s", buf);
				if (slist == NULL)
					slist = plast = p;
				else {
					while (plast->next != NULL)
						plast = plast->next;
					plast->next = p;
					plast = p;
				}
			} 
			else {
				// see how to break
				if (type == 's') {
					p = (struct my_seg_list *)ckalloc(sizeof(struct my_seg_list));
					if (sscanf(buf, "%*d s %*[^.].%[^:]:%d-%d %*[^.].%[^:]:%d-%d %c %d %[^\n]",
							   p->fchr, &(p->fbeg), &(p->fend),
							   p->schr, &(p->sbeg), &(p->send), &(p->orient), &(p->cid), fub) != 9)
						fatalf("cannot parse: %s", buf);
					if (!same_string(fub, "[NP]") && 
						sscanf(fub, "[%d %d %s %d %d %c]", 
									&fgapbeg, &fgapend, gapchrom,
									&sgapbeg, &sgapend, &gaporient) != 6)
						fatalf("cannot parse: %s", buf);
					// look for the position to insert the seg
					tobreak = 0;
					for (q = plast, prp = NULL; q != NULL; q = q->next) {
						if (same_string(p->fchr, q->fchr) 
								&& p->fbeg >= q->fbeg && p->fend <= q->fend) {
							tobreak = 1;
							break;
						}
						if (prp != NULL && same_string(p->fchr, q->fchr)
								&& p->fbeg >= prp->fend && p->fend <= q->fbeg) {
							tobreak = 0;
							break;
						}
						prp = q;
					}
					if (tobreak == 1) {
						// q -> p -> r
						r = (struct my_seg_list *)ckalloc(sizeof(struct my_seg_list));
						p->next = r;
						r->next = q->next;
						q->next = p;
						r->fend = q->fend;
						q->fend = fgapbeg;
						r->fbeg = fgapend;
						strcpy(r->fchr, q->fchr);
						strcpy(r->schr, q->schr);
						r->cid = q->cid;
						r->orient = q->orient;
						if (q->orient == '+') {
							r->send = q->send;
							q->send = sgapbeg;
							r->sbeg = sgapend;
						} 
						else {
							r->sbeg = q->sbeg;
							q->sbeg = sgapend;
							r->send = sgapbeg;
						}
					} 
					else { // tobreak == 0
						if (prp) {
							p->next = prp->next;
							prp->next = p;
						}
						else {
							prp = p;
						}
					}	
				}
				else { // type == 'g'
					tobreak = 0;
					if (sscanf(buf, "%*d g %*[^.].%[^:]:%d-%d %*[^.].%[^:]:%d-%d %c",
								fchrom, &b1, &e1, schrom, &b2, &e2, &ori) != 7)
						fatalf("cannot parse: %s", buf);
					for (q = plast, prp = NULL; q != NULL; q = q->next) {
						if (same_string(fchrom, q->fchr) && b1 >= q->fbeg && e1 <= q->fend) {
							tobreak = 1;
							break;
						}
						if (prp != NULL && same_string(fchrom, q->fchr)
								&& b1 >= prp->fend && e1 <= q->fbeg ) {
							tobreak = 0;
							break;
						}
						prp = q;
					}
					if (tobreak == 1 && same_string(q->schr, schrom)) {
						// q -> r
						r = (struct my_seg_list *)ckalloc(sizeof(struct my_seg_list)); 
						r->next = q->next;
						q->next = r;
						r->fend = q->fend; 
						q->fend = b1; 
						r->fbeg = e1; 
						strcpy(r->fchr, q->fchr); 
						strcpy(r->schr, q->schr); 
						r->orient = q->orient; 
						r->cid = q->cid;
						if (q->orient == '+') { 
							r->send = q->send;
							q->send = b2; 
							r->sbeg = e2; 
						}
						else { 
							r->sbeg = q->sbeg;
							q->sbeg = e2;
							r->send = b2;
						} 
					}
				}
			}
		}
	
		fclose(pf);

		for (p = slist; p != NULL; p = p->next) {
			if (!same_string(p->fchr, prev))
				fprintf(of, "#\n");
			strcpy(prev, p->fchr);
			fprintf(of, "%s.%s:%d-%d %s.%s:%d-%d %c %d\n",
				   Spename[rs], p->fchr, p->fbeg, p->fend,
				   Spename[ss], p->schr, p->sbeg, p->send, p->orient, p->cid);
		}

		free_my_seg_list(slist);
	}
	
	return 0;
}
